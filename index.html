<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Bot Logo Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        .small-loader {
             width: 20px;
             height: 20px;
             border-width: 2px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-4 sm:p-8">

    <div class="w-full max-w-4xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-cyan-400">Crypto Bot Logo Generator</h1>
            <p class="text-gray-400 mt-2">Create unique, iconic logos for your trading bots.</p>
            <p class="text-xs text-gray-500 mt-2">v3.0.1</p>
        </header>

        <!-- Main Controls Section -->
        <section id="controlsSection" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
            <div class="mb-6">
                <label for="apiKeyInput" class="block text-sm font-medium text-gray-300 mb-2">Your Google AI API Key</label>
                <div class="flex items-center gap-4">
                    <input type="password" id="apiKeyInput" placeholder="Enter your API Key here to begin" class="flex-grow bg-gray-700 text-white rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="verifyBtn" onclick="verifyApiKey()" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-md transition duration-300">Verify Key</button>
                </div>
                <div id="apiKeyStatus" class="mt-2 text-sm h-5"></div>
            </div>

            <div class="mb-6">
                 <label for="botNameInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Your Bot Name</label>
                <div class="flex flex-col sm:flex-row gap-4">
                    <input type="text" id="botNameInput" placeholder="e.g., AlgoDragon" class="flex-grow bg-gray-700 text-white rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="generateBtn" onclick="handleCustomNameSubmit()" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-md transition duration-300" disabled>Generate Logos</button>
                </div>
                 <p id="botNameError" class="text-red-400 mt-2 text-sm hidden"></p>
            </div>

            <div class="text-center my-4 text-gray-500">or</div>

            <button id="suggestNameBtn" onclick="suggestBotNames()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-md transition duration-300 w-full" disabled>Suggest Names For Me</button>
            <div id="nameLoader" class="flex justify-center mt-4 hidden">
                <div class="loader"></div>
            </div>
            <div id="nameSuggestions" class="mt-6 grid grid-cols-2 md:grid-cols-5 gap-4"></div>
             <p id="suggestionError" class="text-red-400 mt-4 text-center hidden"></p>
        </section>

        <!-- Results Section -->
        <section id="resultsSection" class="hidden">
             <h2 id="resultsHeader" class="text-3xl font-bold mb-6 text-center"></h2>
             <div id="storySection" class="mb-8"></div>
             <div id="promptResults" class="space-y-8"></div>
             <div class="text-center mt-8">
                 <button onclick="resetApp()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-md transition duration-300">Start Over</button>
             </div>
        </section>

    </div>

    <script>
        let apiKey = '';
        let isKeyVerified = false;
        let currentBotName = '';

        const PROMPT_GENERATION_URL = (model = 'gemini-1.5-flash-latest') => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const IMAGE_GENERATION_URL = () => `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

        // --- Helper Functions ---
        function showLoader(loaderId) { document.getElementById(loaderId).classList.remove('hidden'); }
        function hideLoader(loaderId) { document.getElementById(loaderId).classList.add('hidden'); }
        function showError(elementId, message) {
            const errorEl = document.getElementById(elementId);
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
        }
        function hideError(elementId) { document.getElementById(elementId).classList.add('hidden'); }

        async function verifyApiKey() {
            const inputKey = document.getElementById('apiKeyInput').value.trim();
            if (!inputKey) {
                showError('apiKeyStatus', 'API Key cannot be empty.');
                return;
            }
            apiKey = inputKey;
            
            const statusEl = document.getElementById('apiKeyStatus');
            statusEl.innerHTML = '<div class="flex items-center gap-2"><div class="loader small-loader"></div> Verifying...</div>';
            isKeyVerified = false;
            
            const verifyPayload = { contents: [{ parts: [{ text: "test" }] }] };

            try {
                await fetch(PROMPT_GENERATION_URL(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(verifyPayload)
                });
                await fetch(IMAGE_GENERATION_URL(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({instances: [{ prompt: "test" }]})
                });

                statusEl.textContent = '✅ Verified! You can now generate assets.';
                statusEl.className = 'mt-2 text-sm text-green-400';
                isKeyVerified = true;
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('suggestNameBtn').disabled = false;
                document.getElementById('apiKeyInput').disabled = true;
                document.getElementById('verifyBtn').disabled = true;

            } catch (error) {
                 statusEl.textContent = `❌ Verification Failed: ${error.message}. Check your key and project setup.`;
                 statusEl.className = 'mt-2 text-sm text-red-400';
            }
        }

        async function fetchWithRetry(url, payload, maxRetries = 3, initialBackoff = 1) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return await response.json();
                    }

                    if ((response.status === 429 || response.status >= 500) && attempt < maxRetries - 1) {
                        const backoffTime = initialBackoff * (2 ** attempt) + Math.random();
                        console.log(`API call failed with status ${response.status}. Retrying in ${backoffTime.toFixed(2)}s...`);
                        await new Promise(resolve => setTimeout(resolve, backoffTime * 1000));
                        continue;
                    }
                    
                    const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                    throw new Error(errorData.error.message);

                } catch (error) {
                    if (attempt >= maxRetries - 1) {
                        throw error;
                    }
                }
            }
        }
        
        // --- Core Logic ---

        function handleCustomNameSubmit() {
            if (!isKeyVerified) {
                showError('botNameError', 'Please verify your API key first.');
                return;
            }
            const botName = document.getElementById('botNameInput').value.trim();
            if (!botName) {
                showError('botNameError', 'Please enter a name for your bot.');
                return;
            }
            hideError('botNameError');
            startGenerationProcess(botName);
        }

        async function suggestBotNames() {
            if (!isKeyVerified) {
                showError('suggestionError', 'Please verify your API key first.');
                return;
            }
            
            showLoader('nameLoader');
            document.getElementById('suggestNameBtn').disabled = true;
            const suggestionsContainer = document.getElementById('nameSuggestions');
            suggestionsContainer.innerHTML = '';
            hideError('suggestionError');

            const meta_prompt = "Suggest 10 highly creative and varied names for a new crypto trading bot. Think outside the box. The names can be abstract, mythological, technical, or a blend of concepts. Avoid generic terms. The names should sound modern and unique. Return the names as a JSON array of strings, for example: [\"Helios Cipher\", \"Quantum Weave\", \"Abacus Drift\", \"ChronoLedger\"]. Provide only the JSON array.";
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: {
                    temperature: 0.9,
                }
            };

            try {
                const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
                if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                    throw new Error("Name suggestion failed to return valid content.");
                }
                const rawText = result.candidates[0].content.parts[0].text;
                const jsonResponse = rawText.trim().replace("```json", "").replace("```", "");
                const names = JSON.parse(jsonResponse);

                names.forEach(name => {
                    const button = document.createElement('button');
                    button.textContent = name;
                    button.className = "bg-gray-700 hover:bg-cyan-500 hover:text-white p-4 rounded-lg transition duration-300 text-sm";
                    button.onclick = () => startGenerationProcess(name);
                    suggestionsContainer.appendChild(button);
                });

            } catch (error) {
                console.error("Error suggesting names:", error);
                showError('suggestionError', `Failed to suggest names: ${error.message}`);
            } finally {
                hideLoader('nameLoader');
                document.getElementById('suggestNameBtn').disabled = false;
            }
        }
        
        function startGenerationProcess(name) {
            currentBotName = name;
            document.getElementById('controlsSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('resultsHeader').textContent = `Generating assets for "${name}"`;
            generateAssets(name);
        }

        async function generateStoryElements(botName) {
            const meta_prompt = `Generate a set of creative key elements for a crypto trading bot named '${botName}'. The elements should be imaginative. Return a JSON object with the keys: "location", "time_period", "atmosphere", and "core_concept". Example: {"location": "a data-haven in Neo-Kyoto", "time_period": "the year 2077", "atmosphere": "cyberpunk noir with holographic rain", "core_concept": "a rogue AI seeking digital enlightenment"}. Provide only the JSON object.`;
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: {
                    temperature: 1.0,
                    responseMimeType: "application/json",
                }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                 throw new Error("Story element generation failed to return valid content.");
            }
            return JSON.parse(result.candidates[0].content.parts[0].text);
        }

        async function generateBotStory(botName, storyElements) {
            const meta_prompt = `Write a short, one-paragraph imaginary origin story for a crypto trading bot named '${botName}'. Weave the following elements into the story: Location: ${storyElements.location}, Time Period: ${storyElements.time_period}, Atmosphere: ${storyElements.atmosphere}, Core Concept: ${storyElements.core_concept}. The tone should be slightly futuristic and epic.`;
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: {
                    temperature: 0.8,
                }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                 throw new Error("Story generation failed to return valid content.");
            }
            return result.candidates[0].content.parts[0].text;
        }
        
        async function generateBotSlang(botName, story) {
            const meta_prompt = `Based on the crypto bot named '${botName}' and its origin story, create a short, catchy, and unique slang phrase or motto that its users might say. Story: '${story}'. The slang should be cool and memorable. Return only the slang phrase as a single string.`;
            const payload = {
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: { temperature: 0.9 }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                 throw new Error("Slang generation failed to return valid content.");
            }
            return result.candidates[0].content.parts[0].text;
        }

        async function generatePrompts(botName, numPrompts = 3, custom_meta_prompt = null) {
            const meta_prompt = custom_meta_prompt || `You are an expert in creating prompts for AI image generators. Your task is to generate ${numPrompts} different, concise image generation prompts for a logo for a crypto trading bot named '${botName}'. Each prompt must result in an image that is: minimal, iconic, vector-style, and clearly related to the bot's name and the world of crypto/algorithmic trading. Each prompt should also suggest a unique color atmosphere. Your output MUST be a JSON array of strings, with each string being a prompt. For example: ["prompt 1", "prompt 2"]. Provide only the JSON array.`;
            
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: {
                    temperature: 0.7,
                }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);

            if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                 throw new Error("Prompt generation failed to return valid content.");
            }
            const rawText = result.candidates[0].content.parts[0].text;
            const jsonResponse = rawText.trim().replace(/```json/g, "").replace(/```/g, "");
            return JSON.parse(jsonResponse);
        }
        
        async function generateSinglePrompt(botName, storyElements = null) {
            let meta_prompt;
            if (storyElements) {
                 meta_prompt = `Based on the following story elements, create one concise image generation prompt for a logo for the crypto trading bot named '${botName}'. The prompt must be minimal, iconic, vector-style, and directly reflect the key elements and atmosphere.
                 - Location: ${storyElements.location}
                 - Time Period: ${storyElements.time_period}
                 - Atmosphere: ${storyElements.atmosphere}
                 - Core Concept: ${storyElements.core_concept}
                 Your output MUST be a single JSON string in an array, for example: ["prompt based on elements"].`;
            } else {
                 meta_prompt = `You are an expert in creating prompts for AI image generators. Your task is to generate one concise image generation prompt for a logo for a crypto trading bot named '${botName}'. The prompt must result in an image that is: minimal, iconic, vector-style, and clearly related to the bot's name and the world of crypto/algorithmic trading. It should also suggest a unique color atmosphere. Your output MUST be a single JSON string in an array, for example: ["a new prompt"].`;
            }
            const prompts = await generatePrompts(botName, 1, meta_prompt);
            return prompts[0];
        }

        async function generateImages(prompt, numImages = 2) {
            const payload = {
                instances: [{ prompt }],
                parameters: { sampleCount: numImages }
            };
            
            const result = await fetchWithRetry(IMAGE_GENERATION_URL(), payload);

            if (!result.predictions) {
                throw new Error("API response did not contain image predictions.");
            }
            return result.predictions.map(p => `data:image/png;base64,${p.bytesBase64Encoded}`);
        }

        async function generateAssets(botName) {
            const resultsContainer = document.getElementById('promptResults');
            const storyContainer = document.getElementById('storySection');
            storyContainer.innerHTML = '<div class="flex justify-center"><div class="loader"></div></div>';
            resultsContainer.innerHTML = '';

            let story = null;
            let storyElements = null;
            let slang = null;

            try {
                storyElements = await generateStoryElements(botName);
                story = await generateBotStory(botName, storyElements);
                slang = await generateBotSlang(botName, story);

                const elementsHtml = Object.entries(storyElements).map(([key, value]) => `
                    <div class="bg-gray-700/50 p-2 rounded-md">
                        <p class="text-xs text-gray-400 capitalize">${key.replace('_', ' ')}</p>
                        <p class="text-sm font-medium">${value}</p>
                    </div>
                `).join('');

                storyContainer.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-semibold text-indigo-300">Origin Story</h3>
                            <button onclick="handleRefreshStory('${botName.replace(/'/g, "\\'")}')" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-md text-xs transition duration-300">Refresh Story</button>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4 text-center">
                            ${elementsHtml}
                        </div>
                        <p class="text-gray-300 italic" id="story-text">${story}</p>
                        <div class="border-t border-gray-700 mt-4 pt-4">
                            <p class="text-sm text-gray-400">Bot Motto:</p>
                            <p class="text-lg font-semibold text-cyan-300" id="slang-text">"${slang}"</p>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error("Error generating story assets:", error);
                storyContainer.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg shadow-lg text-red-400">Failed to generate story: ${error.message}</div>`;
            }

            let prompts = [];
            try {
                const [storyBasedPrompt, otherPrompts] = await Promise.all([
                    generateSinglePrompt(botName, storyElements),
                    generatePrompts(botName, 2)
                ]);
                prompts = [storyBasedPrompt, ...otherPrompts];
            } catch (error) {
                console.error("Error generating prompts:", error);
                resultsContainer.innerHTML = `<p class="text-red-400 text-center">Could not generate creative prompts: ${error.message}. Please try again.</p>`;
                return;
            }

            for (let i = 0; i < prompts.length; i++) {
                const prompt = prompts[i];
                
                const promptDiv = document.createElement('div');
                promptDiv.className = 'bg-gray-800 p-6 rounded-lg shadow-lg';
                promptDiv.innerHTML = `
                    <div class="mb-4">
                        <label for="prompt-input-${i}" class="block text-sm font-medium text-gray-300 mb-2">Prompt ${i + 1}</label>
                        <textarea id="prompt-input-${i}" class="w-full bg-gray-700 text-white rounded-md p-3 text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500" rows="3">${prompt}</textarea>
                    </div>
                    <div class="flex gap-4 mb-4">
                        <button onclick="handleRegenerate(${i})" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition duration-300">Regenerate Images</button>
                        <button onclick="handleRefreshPrompt(${i}, '${botName.replace(/'/g, "\\'")}')" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition duration-300">Refresh Prompt</button>
                    </div>
                    <div id="image-container-${i}" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div class="flex justify-center items-center col-span-2"><div class="loader"></div></div>
                    </div>
                `;
                resultsContainer.appendChild(promptDiv);

                try {
                    const images = await generateImages(prompt);
                    displayImages(i, images);
                } catch (error) {
                    console.error(`Error generating images for prompt ${i + 1}:`, error);
                    const imageContainer = document.getElementById(`image-container-${i}`);
                    imageContainer.innerHTML = `<p class="text-red-400 text-center col-span-2">Failed to generate images: ${error.message}</p>`;
                }
            }
        }

        function displayImages(promptIndex, images) {
            const imageContainer = document.getElementById(`image-container-${promptIndex}`);
            imageContainer.innerHTML = '';
            images.forEach(imgData => {
                const imgWrapper = document.createElement('div');
                imgWrapper.className = 'relative group';
                
                const imgElement = document.createElement('img');
                imgElement.src = imgData;
                imgElement.className = 'rounded-lg w-full h-auto shadow-md';
                imgWrapper.appendChild(imgElement);

                const downloadButton = document.createElement('button');
                downloadButton.innerHTML = 'Download';
                downloadButton.className = 'absolute bottom-2 right-2 bg-black bg-opacity-50 text-white text-xs py-1 px-2 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300';
                downloadButton.onclick = () => handleDownload(imgData);
                imgWrapper.appendChild(downloadButton);

                imageContainer.appendChild(imgWrapper);
            });
        }
        
        async function handleRefreshStory(botName) {
            const storyContainer = document.getElementById('storySection');
            storyContainer.innerHTML = '<div class="flex justify-center"><div class="loader"></div></div>';
            try {
                const storyElements = await generateStoryElements(botName);
                const newStory = await generateBotStory(botName, storyElements);
                const newSlang = await generateBotSlang(botName, newStory);

                const elementsHtml = Object.entries(storyElements).map(([key, value]) => `
                    <div class="bg-gray-700/50 p-2 rounded-md">
                        <p class="text-xs text-gray-400 capitalize">${key.replace('_', ' ')}</p>
                        <p class="text-sm font-medium">${value}</p>
                    </div>
                `).join('');

                storyContainer.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-semibold text-indigo-300">Origin Story</h3>
                            <button onclick="handleRefreshStory('${botName.replace(/'/g, "\\'")}')" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-md text-xs transition duration-300">Refresh Story</button>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4 text-center">
                            ${elementsHtml}
                        </div>
                        <p class="text-gray-300 italic" id="story-text">${newStory}</p>
                        <div class="border-t border-gray-700 mt-4 pt-4">
                            <p class="text-sm text-gray-400">Bot Motto:</p>
                            <p class="text-lg font-semibold text-cyan-300" id="slang-text">"${newSlang}"</p>
                        </div>
                    </div>
                `;
                
                const promptInput = document.getElementById('prompt-input-0');
                promptInput.value = "Generating new prompt from story...";
                promptInput.disabled = true;
                const newPrompt = await generateSinglePrompt(botName, storyElements);
                promptInput.value = newPrompt;
                promptInput.disabled = false;
                await handleRegenerate(0);
            } catch (error) {
                console.error("Error refreshing story:", error);
                storyContainer.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg shadow-lg text-red-400">Failed to generate a new story: ${error.message}</div>`;
            }
        }

        async function handleRefreshPrompt(promptIndex, botName) {
            const promptInput = document.getElementById(`prompt-input-${promptIndex}`);
            promptInput.value = "Generating new prompt...";
            promptInput.disabled = true;

            try {
                const newPrompt = await generateSinglePrompt(botName);
                promptInput.value = newPrompt;
                await handleRegenerate(promptIndex);
            } catch (error) {
                console.error("Error refreshing prompt:", error);
                promptInput.value = "Failed to generate new prompt. Please try again.";
            } finally {
                promptInput.disabled = false;
            }
        }

        async function handleRegenerate(promptIndex) {
            const imageContainer = document.getElementById(`image-container-${promptIndex}`);
            imageContainer.innerHTML = '<div class="flex justify-center items-center col-span-2"><div class="loader"></div></div>';
            
            const promptInput = document.getElementById(`prompt-input-${promptIndex}`);
            const updatedPrompt = promptInput.value;

            try {
                const images = await generateImages(updatedPrompt);
                displayImages(promptIndex, images);
            } catch (error) {
                console.error("Error regenerating images:", error);
                imageContainer.innerHTML = `<p class="text-red-400 text-center col-span-2">Failed to generate images: ${error.message}</p>`;
            }
        }

        function handleDownload(imageDataUrl) {
            const link = document.createElement('a');
            link.href = imageDataUrl;
            link.download = `crypto_bot_logo_${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function resetApp() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('controlsSection').classList.remove('hidden');
            
            document.getElementById('apiKeyInput').disabled = false;
            document.getElementById('verifyBtn').disabled = false;

            document.getElementById('generateBtn').disabled = true;
            document.getElementById('suggestNameBtn').disabled = true;

            document.getElementById('botNameInput').value = '';
            document.getElementById('nameSuggestions').innerHTML = '';
            document.getElementById('promptResults').innerHTML = '';
            document.getElementById('storySection').innerHTML = '';
            currentBotName = '';
        }

    </script>
</body>
</html>
