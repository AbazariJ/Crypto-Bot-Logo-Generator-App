<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Bot Logo Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        .small-loader {
             width: 20px;
             height: 20px;
             border-width: 2px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-4 sm:p-8">

    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-cyan-400">Crypto Bot Logo Generator</h1>
            <p class="text-gray-400 mt-2">Create unique, iconic logos for your trading bots.</p>
            <p class="text-xs text-gray-500 mt-2">v5.2.0</p>
        </header>

        <!-- API Key Section -->
        <section id="apiKeySection" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
             <label for="apiKeyInput" class="block text-sm font-medium text-gray-300 mb-2">Your Google AI API Key</label>
            <div class="flex items-center gap-4">
                <input type="password" id="apiKeyInput" placeholder="Enter your API Key to begin" class="flex-grow bg-gray-700 text-white rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                <button id="verifyBtn" onclick="verifyApiKey()" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-md transition duration-300">Verify Key</button>
            </div>
            <div id="apiKeyStatus" class="mt-2 text-sm h-5"></div>
        </section>

        <!-- Creative Flow Section -->
        <section id="creativeFlowSection" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
            <div id="stepContainer"></div>
        </section>

        <!-- Results Section -->
        <section id="resultsSection" class="hidden">
             <h2 id="resultsHeader" class="text-3xl font-bold mb-6 text-center"></h2>
             <div id="storySection" class="mb-8"></div>
             <div id="promptResults" class="space-y-8"></div>
             <div class="text-center mt-8">
                 <button onclick="resetApp()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-md transition duration-300">Start Over</button>
             </div>
        </section>

    </div>

    <script>
        let apiKey = '';
        let isKeyVerified = false;
        let creativeElements = {};

        const PROMPT_GENERATION_URL = (model = 'gemini-1.5-flash-latest') => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const IMAGE_GENERATION_URL = () => `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

        // --- Helper Functions ---
        function showLoader(loaderId) { document.getElementById(loaderId).classList.remove('hidden'); }
        function hideLoader(loaderId) { document.getElementById(loaderId).classList.add('hidden'); }
        function showError(elementId, message) {
            const errorEl = document.getElementById(elementId);
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
        }
        function hideError(elementId) { document.getElementById(elementId).classList.add('hidden'); }

        async function verifyApiKey() {
            const inputKey = document.getElementById('apiKeyInput').value.trim();
            if (!inputKey) {
                showError('apiKeyStatus', 'API Key cannot be empty.');
                return;
            }
            apiKey = inputKey;
            
            const statusEl = document.getElementById('apiKeyStatus');
            statusEl.innerHTML = '<div class="flex items-center gap-2"><div class="loader small-loader"></div> Verifying...</div>';
            isKeyVerified = false;
            
            const verifyPayload = { contents: [{ parts: [{ text: "test" }] }] };

            try {
                await fetch(PROMPT_GENERATION_URL(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(verifyPayload)
                });
                await fetch(IMAGE_GENERATION_URL(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({instances: [{ prompt: "test" }]})
                });

                statusEl.textContent = '✅ Verified! You can now begin the creative process.';
                statusEl.className = 'mt-2 text-sm text-green-400';
                isKeyVerified = true;
                document.getElementById('apiKeyInput').disabled = true;
                document.getElementById('verifyBtn').disabled = true;
                document.getElementById('creativeFlowSection').classList.remove('hidden');
                renderCurrentStep();

            } catch (error) {
                 statusEl.textContent = `❌ Verification Failed: ${error.message}. Check your key and project setup.`;
                 statusEl.className = 'mt-2 text-sm text-red-400';
            }
        }

        async function fetchWithRetry(url, payload, maxRetries = 3, initialBackoff = 1) {
            console.log('API Request:', { url, payload });
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('API Response (Success):', result);
                        return result;
                    }

                    if ((response.status === 429 || response.status >= 500) && attempt < maxRetries - 1) {
                        const backoffTime = initialBackoff * (2 ** attempt) + Math.random();
                        console.warn(`API call failed with status ${response.status}. Retrying in ${backoffTime.toFixed(2)}s...`);
                        await new Promise(resolve => setTimeout(resolve, backoffTime * 1000));
                        continue;
                    }
                    
                    const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                    console.error('API Error (Non-retryable):', errorData);
                    throw new Error(errorData.error.message);

                } catch (error) {
                    console.error(`API Error (Attempt ${attempt + 1}):`, error);
                    if (attempt >= maxRetries - 1) {
                        throw error;
                    }
                }
            }
        }
        
        // --- Creative Flow Logic ---
        const creativeSteps = ['location', 'time_period', 'atmosphere', 'core_concept', 'name'];

        function getCurrentStep() {
            return creativeSteps.find(step => !creativeElements.hasOwnProperty(step));
        }
        
        async function renderCurrentStep() {
            const currentStep = getCurrentStep();
            if (!currentStep) return;

            const container = document.getElementById('stepContainer');
            const currentIndex = creativeSteps.indexOf(currentStep);
            
            let selectedElementsHtml = '';
            if (Object.keys(creativeElements).length > 0) {
                selectedElementsHtml += '<div class="mb-6 border-b border-gray-700 pb-4">';
                selectedElementsHtml += '<h3 class="text-lg font-semibold text-gray-300 mb-2">Your Concept So Far:</h3>';
                selectedElementsHtml += '<div class="flex flex-wrap gap-2">';
                for (const [key, value] of Object.entries(creativeElements)) {
                    selectedElementsHtml += `
                        <div class="bg-gray-700 p-2 rounded-md">
                            <span class="text-xs text-gray-400 capitalize">${key.replace('_', ' ')}:</span>
                            <span class="text-sm font-medium text-cyan-300">${value}</span>
                        </div>
                    `;
                }
                selectedElementsHtml += '</div></div>';
            }
            
            const backButtonHtml = currentIndex > 0 
                ? `<button onclick="goBackStep()" class="text-sm text-gray-400 hover:text-white transition-colors">&larr; Back</button>` 
                : '<div></div>'; // Placeholder for grid alignment

            container.innerHTML = `
                ${selectedElementsHtml}
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold capitalize">Step ${currentIndex + 1}: Choose a ${currentStep.replace('_', ' ')}</h2>
                    ${backButtonHtml}
                </div>
                <div id="step-loader" class="flex justify-center"><div class="loader"></div></div>
                <div id="step-suggestions" class="grid grid-cols-2 md:grid-cols-4 gap-4 my-4"></div>
                <div class="text-center my-4 text-gray-500">or enter your own</div>
                <div class="flex gap-4">
                    <input type="text" id="step-input" class="flex-grow bg-gray-700 text-white rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="Custom ${currentStep.replace('_', ' ')}...">
                    <button onclick="handleStepSelection(true)" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-md transition duration-300">Next</button>
                </div>
                <p id="step-error" class="text-red-400 mt-2 text-sm hidden"></p>
            `;
            
            await generateStepSuggestions();
        }

        function goBackStep() {
            const currentStep = getCurrentStep() || creativeSteps[creativeSteps.length -1];
            const currentIndex = creativeSteps.indexOf(currentStep);
            if (currentIndex === 0) return;

            const previousStep = creativeSteps[currentIndex - 1];
            delete creativeElements[previousStep];
            renderCurrentStep();
        }

        async function generateStepSuggestions() {
            const currentStep = getCurrentStep();
            const suggestionsContainer = document.getElementById('step-suggestions');
            const loader = document.getElementById('step-loader');
            
            let meta_prompt = '';
            switch(currentStep) {
                case 'location':
                    meta_prompt = `Suggest 4 highly creative and varied locations (under 5 words each) for a crypto bot's origin story. Think futuristic, mythical, or abstract. Return as a JSON array of strings.`;
                    break;
                case 'time_period':
                    meta_prompt = `Based on the location "${creativeElements.location}", suggest 4 fitting time periods (under 5 words each, e.g., "The Neon Epoch", "A distant future"). Return as a JSON array of strings.`;
                    break;
                case 'atmosphere':
                    meta_prompt = `For a story in "${creativeElements.location}" during "${creativeElements.time_period}", suggest 4 distinct atmospheres (under 5 words each, e.g., "Cyberpunk noir", "Hopeful solarpunk"). Return as a JSON array of strings.`;
                    break;
                case 'core_concept':
                    meta_prompt = `Given: ${creativeElements.location}, ${creativeElements.time_period}, with a ${creativeElements.atmosphere} atmosphere, suggest 4 unique core concepts (under 5 words each) for a trading bot's purpose. Return as a JSON array of strings.`;
                    break;
                case 'name':
                    meta_prompt = `Based on these elements: ${JSON.stringify(creativeElements)}, suggest 4 creative two-part names for a crypto bot. Return as a JSON array of strings.`;
                    break;
            }

            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: { temperature: 1.0, responseMimeType: "application/json" }
            };

            try {
                const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
                const suggestions = JSON.parse(result.candidates[0].content.parts[0].text);
                suggestionsContainer.innerHTML = '';
                suggestions.forEach(suggestion => {
                    const button = document.createElement('button');
                    button.textContent = suggestion;
                    button.className = "bg-gray-700 hover:bg-cyan-500 hover:text-white p-4 rounded-lg transition duration-300";
                    button.onclick = () => handleStepSelection(false, suggestion);
                    suggestionsContainer.appendChild(button);
                });
            } catch (error) {
                showError('step-error', `Failed to get suggestions: ${error.message}`);
                suggestionsContainer.innerHTML = '';
            } finally {
                loader.classList.add('hidden');
            }
        }

        function handleStepSelection(isCustom, value = '') {
            const currentStep = getCurrentStep();
            const selectedValue = isCustom ? document.getElementById('step-input').value.trim() : value;
            
            if (!selectedValue) {
                showError('step-error', 'Please make a selection or enter a value.');
                return;
            }

            creativeElements[currentStep] = selectedValue;

            if (currentStep === 'name') {
                document.getElementById('creativeFlowSection').classList.add('hidden');
                startGenerationProcess(selectedValue, creativeElements);
            } else {
                renderCurrentStep();
            }
        }

        // --- Asset Generation Logic ---
        
        function startGenerationProcess(name, elements) {
            document.getElementById('creativeFlowSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('resultsHeader').textContent = `Generating assets for "${name}"`;
            generateAssets(name, elements);
        }

        async function generateBotStory(botName, storyElements) {
            const meta_prompt = `Write a short, one-paragraph imaginary origin story for a crypto trading bot named '${botName}'. Weave the following elements into the story: Location: ${storyElements.location}, Time Period: ${storyElements.time_period}, Atmosphere: ${storyElements.atmosphere}, Core Concept: ${storyElements.core_concept}. The tone should be slightly futuristic and epic.`;
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: { temperature: 0.8 }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            return result.candidates[0].content.parts[0].text;
        }
        
        async function generateBotSlang(botName, story) {
            const meta_prompt = `Based on the crypto bot named '${botName}' and its origin story, create a short, catchy, and unique slang phrase or motto that its users might say. Story: '${story}'. Return only the slang phrase.`;
            const payload = {
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: { temperature: 0.9 }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            return result.candidates[0].content.parts[0].text;
        }

        async function generateAllPrompts(botName, storyElements) {
            const meta_prompt = `You are an expert in creating prompts for AI image generators for a crypto bot named '${botName}'. Based on the following story elements, generate 3 distinct and descriptive prompts.
            - Location: ${storyElements.location}
            - Time Period: ${storyElements.time_period}
            - Atmosphere: ${storyElements.atmosphere}
            - Core Concept: ${storyElements.core_concept}
            Instructions:
            1.  **Prompt 1 (Logo):** Create a detailed prompt for a minimal, iconic, vector-style logo. It must directly reflect the core concept and atmosphere.
            2.  **Prompt 2 (Logo Variant):** Create a second, different logo prompt, perhaps focusing on the location or time period elements.
            3.  **Prompt 3 (Animation Concept):** Describe a minimal, atmospheric animation or GIF concept related to the bot's function. It should feel like a loading screen or a dynamic background.
            Your output MUST be a JSON array of 3 strings. Provide only the JSON array.`;
            
            const payload = { 
                contents: [{ parts: [{ text: meta_prompt }] }],
                generationConfig: { temperature: 0.8, responseMimeType: "application/json" }
            };
            const result = await fetchWithRetry(PROMPT_GENERATION_URL(), payload);
            return JSON.parse(result.candidates[0].content.parts[0].text);
        }

        async function generateImages(prompt, numImages = 2) {
            const payload = {
                instances: [{ prompt }],
                parameters: { sampleCount: numImages }
            };
            const result = await fetchWithRetry(IMAGE_GENERATION_URL(), payload);
            if (!result.predictions) throw new Error("API response did not contain image predictions.");
            return result.predictions.map(p => `data:image/png;base64,${p.bytesBase64Encoded}`);
        }

        async function generateAssets(botName, storyElements) {
            const resultsContainer = document.getElementById('promptResults');
            const storyContainer = document.getElementById('storySection');
            storyContainer.innerHTML = '<div class="flex justify-center"><div class="loader"></div></div>';
            resultsContainer.innerHTML = '';

            try {
                if (!storyElements) {
                    storyElements = await generateStoryElements(botName);
                }
                
                const story = await generateBotStory(botName, storyElements);
                const slang = await generateBotSlang(botName, story);

                const elementsHtml = Object.entries(storyElements).map(([key, value]) => `
                    <div class="bg-gray-700/50 p-2 rounded-md">
                        <p class="text-xs text-gray-400 capitalize">${key.replace('_', ' ')}</p>
                        <p class="text-sm font-medium">${value}</p>
                    </div>
                `).join('');

                storyContainer.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <h3 class="text-xl font-semibold text-indigo-300 mb-4">Origin Story</h3>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4 text-center">${elementsHtml}</div>
                        <p class="text-gray-300 italic" id="story-text">${story}</p>
                        <div class="border-t border-gray-700 mt-4 pt-4">
                            <p class="text-sm text-gray-400">Bot Motto:</p>
                            <p class="text-lg font-semibold text-cyan-300" id="slang-text">"${slang}"</p>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error("Error generating story assets:", error);
                storyContainer.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg shadow-lg text-red-400">Failed to generate story: ${error.message}</div>`;
            }

            let prompts = [];
            try {
                prompts = await generateAllPrompts(botName, storyElements);
            } catch (error) {
                console.error("Error generating prompts:", error);
                resultsContainer.innerHTML = `<p class="text-red-400 text-center">Could not generate creative prompts: ${error.message}. Please try again.</p>`;
                return;
            }

            for (let i = 0; i < prompts.length; i++) {
                const prompt = prompts[i];
                const promptDiv = document.createElement('div');
                promptDiv.className = 'bg-gray-800 p-6 rounded-lg shadow-lg';
                promptDiv.innerHTML = `
                    <div class="mb-4">
                        <label for="prompt-input-${i}" class="block text-sm font-medium text-gray-300 mb-2">Prompt ${i + 1}</label>
                        <textarea id="prompt-input-${i}" class="w-full bg-gray-700 text-white rounded-md p-3 text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500" rows="4">${prompt}</textarea>
                    </div>
                    <div class="flex gap-4 mb-4">
                        <button onclick="handleRegenerate(${i})" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition duration-300">Regenerate Images</button>
                    </div>
                    <div id="image-container-${i}" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div class="flex justify-center items-center col-span-2"><div class="loader"></div></div>
                    </div>
                `;
                resultsContainer.appendChild(promptDiv);

                try {
                    const images = await generateImages(prompt);
                    displayImages(i, images);
                } catch (error) {
                    console.error(`Error generating images for prompt ${i + 1}:`, error);
                    document.getElementById(`image-container-${i}`).innerHTML = `<p class="text-red-400 text-center col-span-2">Failed to generate images: ${error.message}</p>`;
                }
            }
        }

        function displayImages(promptIndex, images) {
            const imageContainer = document.getElementById(`image-container-${promptIndex}`);
            imageContainer.innerHTML = '';
            images.forEach(imgData => {
                const imgWrapper = document.createElement('div');
                imgWrapper.className = 'relative group';
                
                const imgElement = document.createElement('img');
                imgElement.src = imgData;
                imgElement.className = 'rounded-lg w-full h-auto shadow-md';
                imgWrapper.appendChild(imgElement);

                const downloadButton = document.createElement('button');
                downloadButton.innerHTML = 'Download';
                downloadButton.className = 'absolute bottom-2 right-2 bg-black bg-opacity-50 text-white text-xs py-1 px-2 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300';
                downloadButton.onclick = () => handleDownload(imgData);
                imgWrapper.appendChild(downloadButton);

                imageContainer.appendChild(imgWrapper);
            });
        }

        async function handleRegenerate(promptIndex) {
            const imageContainer = document.getElementById(`image-container-${promptIndex}`);
            imageContainer.innerHTML = '<div class="flex justify-center items-center col-span-2"><div class="loader"></div></div>';
            
            const promptInput = document.getElementById(`prompt-input-${promptIndex}`);
            const updatedPrompt = promptInput.value;

            try {
                const images = await generateImages(updatedPrompt);
                displayImages(promptIndex, images);
            } catch (error) {
                console.error("Error regenerating images:", error);
                imageContainer.innerHTML = `<p class="text-red-400 text-center col-span-2">Failed to generate images: ${error.message}</p>`;
            }
        }

        function handleDownload(imageDataUrl) {
            const link = document.createElement('a');
            link.href = imageDataUrl;
            link.download = `crypto_bot_logo_${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function resetApp() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('creativeFlowSection').classList.add('hidden');
            document.getElementById('apiKeySection').classList.remove('hidden');
            
            document.getElementById('apiKeyInput').disabled = false;
            document.getElementById('apiKeyInput').value = '';
            document.getElementById('verifyBtn').disabled = false;
            document.getElementById('apiKeyStatus').textContent = '';
            
            document.getElementById('promptResults').innerHTML = '';
            document.getElementById('storySection').innerHTML = '';
            creativeElements = {};
        }

    </script>
</body>
</html>
